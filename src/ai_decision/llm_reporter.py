"""
LLM Reporter - CyberGuard AI
=============================

Large Language Model tabanlÄ± IDS raporlama modÃ¼lÃ¼.

Ã–zellikler:
    - Human-readable attack explanations
    - SOC analyst reports
    - Natural language summaries
    - Prompt-based reporting
    - Offline/local LLM support
"""

import os
import sys
from typing import Dict, List, Optional, Union
from datetime import datetime
import logging
import json

PROJECT_ROOT = os.path.dirname(
    os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
)
sys.path.insert(0, PROJECT_ROOT)

logger = logging.getLogger("LLMReporter")


# Report templates
REPORT_TEMPLATES = {
    "attack_summary": """
ðŸš¨ SECURITY ALERT - {attack_type}

**Severity:** {severity}
**Confidence:** {confidence:.1%}
**Timestamp:** {timestamp}

## Attack Summary
{description}

## Key Indicators
{indicators}

## Affected Systems
- Source: {source_info}
- Target: {target_info}

## Recommended Actions
{recommendations}

---
*Generated by CyberGuard AI - AI-Driven Intelligent IDS*
""",
    "zero_day_alert": """
âš ï¸ ZERO-DAY ATTACK DETECTED

**Type:** Unknown (Novel Attack Pattern)
**Anomaly Score:** {anomaly_score:.2f}
**Detection Method:** VAE Reconstruction Error

## Why This is Suspicious
The traffic pattern differs significantly from known normal behavior:
{explanation}

## Evidence
- Reconstruction error: {raw_error:.4f} (threshold: {threshold:.4f})
- Top anomalous features: {anomalous_features}

## Immediate Actions Required
1. ðŸ”’ Isolate affected systems
2. ðŸ“Š Capture network traffic for forensic analysis
3. ðŸ” Investigate source IPs
4. ðŸ“¢ Notify security team

## Next Steps
Contact your security operations center for detailed investigation.
""",
    "soc_report": """
# Security Operations Center - Incident Report

**Report ID:** {report_id}
**Generated:** {timestamp}
**Analyst:** CyberGuard AI System

---

## Executive Summary
{executive_summary}

## Technical Details

### Attack Classification
- **Type:** {attack_type}
- **Confidence:** {confidence:.1%}
- **Severity:** {severity}
- **MITRE ATT&CK:** {mitre_mapping}

### Traffic Analysis
{traffic_analysis}

### Feature Attribution (Top 5)
{feature_attribution}

### Timeline
{timeline}

## Impact Assessment
{impact_assessment}

## Recommendations
{recommendations}

## Appendix
- Model used: {model_name}
- Detection timestamp: {detection_time}
- Processing latency: {latency_ms}ms

---
*This report was automatically generated by CyberGuard AI Intelligent IDS*
""",
    "quick_alert": """
ðŸ”” **{severity} Alert:** {attack_type} detected
ðŸ“ Target: {target_info}
ðŸŽ¯ Confidence: {confidence:.0%}
ðŸ’¡ Action: {quick_action}
""",
}

# MITRE ATT&CK Mappings
MITRE_MAPPING = {
    "DDoS": "T1498 - Network Denial of Service",
    "DoS": "T1499 - Endpoint Denial of Service",
    "PortScan": "T1046 - Network Service Scanning",
    "Probe": "T1046 - Network Service Scanning",
    "BruteForce": "T1110 - Brute Force",
    "WebAttack": "T1190 - Exploit Public-Facing Application",
    "Bot": "T1583 - Acquire Infrastructure: Botnet",
    "Infiltration": "T1078 - Valid Accounts",
    "ZERO_DAY": "Unknown - Novel Attack Pattern",
}

# Severity mapping
SEVERITY_MAP = {
    "Normal": "INFO",
    "ZERO_DAY": "CRITICAL",
    "DDoS": "HIGH",
    "DoS": "HIGH",
    "BruteForce": "HIGH",
    "WebAttack": "HIGH",
    "Probe": "MEDIUM",
    "PortScan": "MEDIUM",
    "Bot": "HIGH",
    "Infiltration": "CRITICAL",
}


class LLMReporter:
    """
    LLM-based Attack Report Generator

    Template-based reporting with optional LLM enhancement.
    """

    def __init__(
        self,
        llm_provider: str = "template",  # template, groq, local
        api_key: str = None,
        model_name: str = "llama3-70b-8192",
    ):
        """
        Args:
            llm_provider: Report generation method
            api_key: API key for external LLM (optional)
            model_name: LLM model name
        """
        self.llm_provider = llm_provider
        self.api_key = api_key
        self.model_name = model_name

        self.templates = REPORT_TEMPLATES
        self.mitre_mapping = MITRE_MAPPING
        self.severity_map = SEVERITY_MAP

        # Report history
        self.report_history = []

        logger.info(f"ðŸ“ LLMReporter initialized")
        logger.info(f"   Provider: {llm_provider}")

    def generate_attack_report(
        self,
        attack_type: str,
        confidence: float,
        explanation: Dict = None,
        source_info: str = "Unknown",
        target_info: str = "Unknown",
        template: str = "attack_summary",
    ) -> str:
        """
        Generate attack report

        Args:
            attack_type: Detected attack type
            confidence: Detection confidence
            explanation: XAI explanation dict
            source_info: Source IP/system
            target_info: Target IP/system
            template: Report template to use

        Returns:
            Formatted report string
        """
        explanation = explanation or {}

        # Prepare data
        data = {
            "attack_type": attack_type,
            "confidence": confidence,
            "severity": self.severity_map.get(attack_type, "MEDIUM"),
            "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            "description": explanation.get(
                "description", f"{attack_type} attack detected"
            ),
            "indicators": self._format_indicators(explanation.get("evidence", [])),
            "source_info": source_info,
            "target_info": target_info,
            "recommendations": (
                explanation.get("explanation", "Monitor and investigate.").split(
                    "Recommended: "
                )[-1]
                if explanation.get("explanation")
                else "Monitor and investigate."
            ),
        }

        # Generate report
        if self.llm_provider == "template":
            report = self._template_report(template, data)
        elif self.llm_provider == "groq":
            report = self._llm_report(data)
        else:
            report = self._template_report(template, data)

        # Store history
        self.report_history.append(
            {
                "attack_type": attack_type,
                "timestamp": data["timestamp"],
                "report": report[:500],  # Store first 500 chars
            }
        )

        return report

    def generate_zero_day_report(
        self,
        anomaly_score: float,
        raw_error: float,
        threshold: float,
        anomalous_features: List[str] = None,
        explanation: str = None,
    ) -> str:
        """Generate zero-day attack report"""
        data = {
            "anomaly_score": anomaly_score,
            "raw_error": raw_error,
            "threshold": threshold,
            "anomalous_features": ", ".join(anomalous_features or ["Unknown"]),
            "explanation": explanation
            or "Traffic pattern differs significantly from baseline.",
        }

        return self._template_report("zero_day_alert", data)

    def generate_soc_report(
        self,
        attack_type: str,
        confidence: float,
        explanation: Dict = None,
        traffic_analysis: str = None,
        model_name: str = "Unknown",
        latency_ms: float = 0,
    ) -> str:
        """Generate full SOC report"""
        explanation = explanation or {}

        data = {
            "report_id": f"INC-{datetime.now().strftime('%Y%m%d%H%M%S')}",
            "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            "executive_summary": self._generate_executive_summary(
                attack_type, confidence
            ),
            "attack_type": attack_type,
            "confidence": confidence,
            "severity": self.severity_map.get(attack_type, "MEDIUM"),
            "mitre_mapping": self.mitre_mapping.get(attack_type, "Unknown"),
            "traffic_analysis": traffic_analysis or "Traffic analysis pending.",
            "feature_attribution": self._format_features(
                explanation.get("top_features", [])
            ),
            "timeline": f"Detected at {datetime.now().strftime('%H:%M:%S')}",
            "impact_assessment": self._assess_impact(attack_type, confidence),
            "recommendations": self._generate_recommendations(attack_type),
            "model_name": model_name,
            "detection_time": datetime.now().isoformat(),
            "latency_ms": latency_ms,
        }

        return self._template_report("soc_report", data)

    def generate_quick_alert(
        self,
        attack_type: str,
        confidence: float,
        target_info: str = "Unknown",
    ) -> str:
        """Generate quick alert message"""
        severity = self.severity_map.get(attack_type, "MEDIUM")
        quick_action = self._get_quick_action(attack_type)

        data = {
            "severity": severity,
            "attack_type": attack_type,
            "target_info": target_info,
            "confidence": confidence,
            "quick_action": quick_action,
        }

        return self._template_report("quick_alert", data)

    def _template_report(self, template_name: str, data: Dict) -> str:
        """Template-based report generation"""
        template = self.templates.get(template_name, self.templates["attack_summary"])

        try:
            return template.format(**data)
        except KeyError as e:
            logger.warning(f"Template key missing: {e}")
            # Fill missing keys with placeholders
            for key in self._extract_template_keys(template):
                if key not in data:
                    data[key] = f"[{key}]"
            return template.format(**data)

    def _extract_template_keys(self, template: str) -> List[str]:
        """Extract keys from template string"""
        import re

        return re.findall(r"\{(\w+)[:\.\}]", template)

    def _llm_report(self, data: Dict) -> str:
        """LLM-enhanced report generation"""
        # This would call an external LLM API
        # For now, fallback to template
        logger.info("LLM report generation - falling back to template")
        return self._template_report("attack_summary", data)

    def _format_indicators(self, evidence: List[str]) -> str:
        """Format evidence list"""
        if not evidence:
            return "- No specific indicators identified"
        return "\n".join(f"- {e}" for e in evidence[:5])

    def _format_features(self, features: List[Dict]) -> str:
        """Format feature attribution"""
        if not features:
            return "Feature attribution not available."

        lines = []
        for i, f in enumerate(features[:5], 1):
            name = f.get("name", "Unknown")
            importance = f.get("importance", 0)
            lines.append(f"{i}. {name}: {importance*100:.1f}%")

        return "\n".join(lines)

    def _generate_executive_summary(self, attack_type: str, confidence: float) -> str:
        """Generate executive summary"""
        severity = self.severity_map.get(attack_type, "MEDIUM")

        if attack_type == "ZERO_DAY":
            return f"A novel attack pattern was detected with high anomaly score. Immediate investigation recommended."

        return f"A {attack_type} attack was detected with {confidence:.0%} confidence. Severity level: {severity}."

    def _assess_impact(self, attack_type: str, confidence: float) -> str:
        """Assess attack impact"""
        if confidence > 0.9:
            level = "HIGH"
        elif confidence > 0.7:
            level = "MEDIUM"
        else:
            level = "LOW"

        impacts = {
            "DDoS": f"Potential service disruption. Impact level: {level}",
            "DoS": f"Single target service disruption. Impact level: {level}",
            "BruteForce": f"Risk of unauthorized access. Impact level: {level}",
            "WebAttack": f"Application-level compromise risk. Impact level: {level}",
            "ZERO_DAY": "Unknown impact - immediate investigation required.",
            "PortScan": f"Reconnaissance activity detected. Impact level: {level}",
            "Bot": f"Possible botnet infection. Impact level: {level}",
            "Infiltration": f"Internal network compromise. Impact level: CRITICAL",
        }

        return impacts.get(
            attack_type, f"General security threat. Impact level: {level}"
        )

    def _generate_recommendations(self, attack_type: str) -> str:
        """Generate recommendations"""
        recs = {
            "DDoS": """
1. Enable DDoS mitigation services
2. Implement rate limiting
3. Contact ISP for upstream filtering
4. Prepare incident response team""",
            "DoS": """
1. Block source IP at firewall
2. Implement connection rate limits
3. Monitor for distributed attacks
4. Document for forensics""",
            "BruteForce": """
1. Enable account lockout policies
2. Implement CAPTCHA
3. Review authentication logs
4. Consider MFA deployment""",
            "WebAttack": """
1. Update WAF rules
2. Review application logs
3. Patch vulnerable applications
4. Conduct security assessment""",
            "ZERO_DAY": """
1. IMMEDIATE: Isolate affected systems
2. Capture full network traffic
3. Perform forensic analysis
4. Contact incident response team
5. Prepare for potential escalation""",
            "PortScan": """
1. Review firewall rules
2. Close unnecessary ports
3. Monitor for follow-up attacks
4. Log scanning activity""",
        }

        return recs.get(
            attack_type,
            """
1. Monitor affected systems
2. Review security logs
3. Update detection rules
4. Document incident""",
        )

    def _get_quick_action(self, attack_type: str) -> str:
        """Get quick action for alert"""
        actions = {
            "DDoS": "Enable rate limiting",
            "DoS": "Block source IP",
            "BruteForce": "Enable account lockout",
            "WebAttack": "Review WAF logs",
            "ZERO_DAY": "ISOLATE SYSTEMS IMMEDIATELY",
            "PortScan": "Monitor for follow-up",
            "Bot": "Quarantine infected host",
            "Infiltration": "Revoke compromised credentials",
        }
        return actions.get(attack_type, "Investigate immediately")

    def get_report_history(self, limit: int = 10) -> List[Dict]:
        """Get recent reports"""
        return self.report_history[-limit:]

    def get_stats(self) -> Dict:
        """Reporter statistics"""
        attack_counts = {}
        for report in self.report_history:
            attack_type = report["attack_type"]
            attack_counts[attack_type] = attack_counts.get(attack_type, 0) + 1

        return {
            "total_reports": len(self.report_history),
            "attack_distribution": attack_counts,
            "llm_provider": self.llm_provider,
        }


# ============= Factory Functions =============


def create_reporter(
    use_llm: bool = False,
    api_key: str = None,
) -> LLMReporter:
    """Create LLM reporter"""
    provider = "groq" if use_llm and api_key else "template"
    return LLMReporter(llm_provider=provider, api_key=api_key)


def quick_report(
    attack_type: str,
    confidence: float,
    explanation: Dict = None,
) -> str:
    """Generate quick attack report"""
    reporter = LLMReporter()
    return reporter.generate_attack_report(attack_type, confidence, explanation)


# ============= Test =============

if __name__ == "__main__":
    print("ðŸ§ª LLM Reporter Test\n")

    reporter = LLMReporter()

    # Test attack report
    print("=" * 50)
    print("ATTACK REPORT TEST")
    print("=" * 50)

    report = reporter.generate_attack_report(
        attack_type="DDoS",
        confidence=0.95,
        explanation={
            "description": "Distributed denial of service attack detected",
            "evidence": [
                "Packet rate â†‘ 15,000 pps",
                "Flow duration â†‘",
                "Multiple source IPs",
            ],
            "explanation": "High packet rate from distributed sources. Recommended: Enable rate limiting.",
        },
        source_info="Multiple IPs (45.33.x.x/24)",
        target_info="192.168.1.10:443",
    )
    print(report)

    # Test zero-day report
    print("\n" + "=" * 50)
    print("ZERO-DAY REPORT TEST")
    print("=" * 50)

    zd_report = reporter.generate_zero_day_report(
        anomaly_score=0.87,
        raw_error=0.0234,
        threshold=0.0150,
        anomalous_features=["flow_duration", "packet_rate", "entropy"],
        explanation="Traffic pattern does not match any known attack signatures.",
    )
    print(zd_report)

    # Test quick alert
    print("\n" + "=" * 50)
    print("QUICK ALERT TEST")
    print("=" * 50)

    quick = reporter.generate_quick_alert("BruteForce", 0.88, "auth.example.com:22")
    print(quick)

    print("\nâœ… Test completed!")
