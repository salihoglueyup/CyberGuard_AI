"""
File Processor - CyberGuard AI
Dosya Ã¶zellik Ã§Ä±karÄ±mÄ± ve hash hesaplama

Dosya Yolu: src/malware_detection/file_processor.py
"""

import os
import hashlib
import math
from typing import Dict, List, Optional, Tuple
from datetime import datetime
import struct


class FileProcessor:
    """
    Dosya analizi ve Ã¶zellik Ã§Ä±karÄ±mÄ±
    
    Ã–zellikler:
    - Hash hesaplama (MD5, SHA256)
    - Entropy hesaplama
    - PE header analizi (Windows executable)
    - Dosya metadata Ã§Ä±karÄ±mÄ±
    """
    
    # Bilinen zararlÄ± dosya uzantÄ±larÄ±
    SUSPICIOUS_EXTENSIONS = {
        '.exe', '.dll', '.bat', '.cmd', '.ps1', '.vbs', '.js',
        '.jar', '.msi', '.scr', '.com', '.pif', '.application'
    }
    
    # PE signature
    PE_SIGNATURE = b'MZ'
    
    def __init__(self):
        """File Processor baÅŸlat"""
        print("ğŸ“ File Processor baÅŸlatÄ±ldÄ±")
    
    def calculate_hashes(self, file_path: str) -> Dict[str, str]:
        """
        Dosya hash'lerini hesapla
        
        Args:
            file_path: Dosya yolu
            
        Returns:
            Hash dictionary (md5, sha256)
        """
        if not os.path.exists(file_path):
            raise FileNotFoundError(f"Dosya bulunamadÄ±: {file_path}")
        
        md5 = hashlib.md5()
        sha256 = hashlib.sha256()
        
        with open(file_path, 'rb') as f:
            while chunk := f.read(8192):
                md5.update(chunk)
                sha256.update(chunk)
        
        return {
            'md5': md5.hexdigest(),
            'sha256': sha256.hexdigest()
        }
    
    def calculate_entropy(self, file_path: str) -> float:
        """
        Dosya entropy'sini hesapla (0-8 arasÄ±)
        YÃ¼ksek entropy = ÅŸifreli/sÄ±kÄ±ÅŸtÄ±rÄ±lmÄ±ÅŸ = potansiyel malware
        
        Args:
            file_path: Dosya yolu
            
        Returns:
            Entropy deÄŸeri (0-8)
        """
        if not os.path.exists(file_path):
            return 0.0
        
        with open(file_path, 'rb') as f:
            data = f.read()
        
        if not data:
            return 0.0
        
        # Byte frekanslarÄ±
        freq = [0] * 256
        for byte in data:
            freq[byte] += 1
        
        # Shannon entropy
        entropy = 0.0
        length = len(data)
        
        for count in freq:
            if count > 0:
                p = count / length
                entropy -= p * math.log2(p)
        
        return round(entropy, 4)
    
    def get_file_info(self, file_path: str) -> Dict:
        """
        Dosya bilgilerini al
        
        Args:
            file_path: Dosya yolu
            
        Returns:
            Dosya bilgileri dictionary
        """
        if not os.path.exists(file_path):
            raise FileNotFoundError(f"Dosya bulunamadÄ±: {file_path}")
        
        stat = os.stat(file_path)
        _, ext = os.path.splitext(file_path)
        
        return {
            'name': os.path.basename(file_path),
            'path': os.path.abspath(file_path),
            'size': stat.st_size,
            'extension': ext.lower(),
            'created': datetime.fromtimestamp(stat.st_ctime).isoformat(),
            'modified': datetime.fromtimestamp(stat.st_mtime).isoformat(),
            'is_suspicious_ext': ext.lower() in self.SUSPICIOUS_EXTENSIONS
        }
    
    def is_pe_file(self, file_path: str) -> bool:
        """
        PE (Portable Executable) dosyasÄ± mÄ± kontrol et
        
        Args:
            file_path: Dosya yolu
            
        Returns:
            PE dosyasÄ± mÄ±
        """
        try:
            with open(file_path, 'rb') as f:
                header = f.read(2)
                return header == self.PE_SIGNATURE
        except:
            return False
    
    def extract_pe_features(self, file_path: str) -> Optional[Dict]:
        """
        PE dosyasÄ±ndan Ã¶zellik Ã§Ä±kar
        
        Args:
            file_path: Dosya yolu
            
        Returns:
            PE Ã¶zellikleri veya None
        """
        if not self.is_pe_file(file_path):
            return None
        
        try:
            with open(file_path, 'rb') as f:
                # MZ header
                f.seek(0x3C)
                pe_offset = struct.unpack('<I', f.read(4))[0]
                
                # PE header
                f.seek(pe_offset)
                pe_sig = f.read(4)
                
                if pe_sig != b'PE\x00\x00':
                    return None
                
                # COFF header
                machine = struct.unpack('<H', f.read(2))[0]
                num_sections = struct.unpack('<H', f.read(2))[0]
                timestamp = struct.unpack('<I', f.read(4))[0]
                
                return {
                    'is_pe': True,
                    'machine': hex(machine),
                    'num_sections': num_sections,
                    'timestamp': timestamp,
                    'compile_date': datetime.fromtimestamp(timestamp).isoformat() if timestamp > 0 else None
                }
        except Exception as e:
            return {'is_pe': True, 'error': str(e)}
    
    def extract_all_features(self, file_path: str) -> Dict:
        """
        TÃ¼m Ã¶zellikleri Ã§Ä±kar
        
        Args:
            file_path: Dosya yolu
            
        Returns:
            TÃ¼m Ã¶zellikler dictionary
        """
        features = {}
        
        # Temel bilgiler
        features['file_info'] = self.get_file_info(file_path)
        
        # Hash'ler
        features['hashes'] = self.calculate_hashes(file_path)
        
        # Entropy
        features['entropy'] = self.calculate_entropy(file_path)
        
        # Entropy risk deÄŸerlendirmesi
        if features['entropy'] > 7.5:
            features['entropy_risk'] = 'high'
        elif features['entropy'] > 6.5:
            features['entropy_risk'] = 'medium'
        else:
            features['entropy_risk'] = 'low'
        
        # PE Ã¶zellikleri
        pe_features = self.extract_pe_features(file_path)
        if pe_features:
            features['pe_info'] = pe_features
        
        return features
    
    def get_feature_vector(self, file_path: str) -> List[float]:
        """
        ML modeli iÃ§in Ã¶zellik vektÃ¶rÃ¼ oluÅŸtur
        
        Args:
            file_path: Dosya yolu
            
        Returns:
            Ã–zellik vektÃ¶rÃ¼
        """
        features = self.extract_all_features(file_path)
        
        vector = [
            features['file_info']['size'] / 1e6,  # MB cinsinden
            features['entropy'] / 8.0,  # Normalize
            1.0 if features['file_info']['is_suspicious_ext'] else 0.0,
            1.0 if features.get('pe_info', {}).get('is_pe', False) else 0.0,
            features.get('pe_info', {}).get('num_sections', 0) / 20.0,  # Normalize
        ]
        
        return vector


# Test
if __name__ == "__main__":
    processor = FileProcessor()
    
    # Test dosyasÄ± oluÅŸtur
    test_file = "test_file.txt"
    with open(test_file, 'w') as f:
        f.write("Bu bir test dosyasÄ±dÄ±r.")
    
    # Ã–zellikleri Ã§Ä±kar
    features = processor.extract_all_features(test_file)
    print(f"\nğŸ“ Dosya: {features['file_info']['name']}")
    print(f"ğŸ“Š Boyut: {features['file_info']['size']} bytes")
    print(f"ğŸ” MD5: {features['hashes']['md5']}")
    print(f"ğŸ“ˆ Entropy: {features['entropy']}")
    
    # Temizlik
    os.remove(test_file)
